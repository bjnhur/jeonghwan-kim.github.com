---
title: 깃(Git) 개념과 상활별 팁
layout: post
category: dev
tags: git
---

[git-usage](https://github.com/jeonghwan-kim/git-usage) 저장소가 어느새 스타 100을 넘었다. 
에버노트에 정리한 것을 깃헙에 공유한 것인데 필요한 분들이 그만큼 많았나 보다. 
다시 쭉 읽어보니 기억하기 위해 메모 형식으로 명령어만 나열해서 이해하기 어려운 부분도 있을 것 같다. 
여기에 살을 덧붙여 "깃 노하우" 혹은 "팁"을 정리해 보면 좋겠다. 

# 기본 개념과 명령어

## 깃 초기화

깃을 올바로 사용하려면 깃이 파일의 변경내용을 추적하는 방식을 이해하는 것이 중요하다.
현재 폴더를 깃이 트래킹하도록 하려면 여기에 깃 저장소를 먼저 만들어야 한다.

```
git init
```

현재 폴더에 .git 폴더가 하나 생긴다. 깃은 이 폴더에 변경내용을 추적하는 정보를 담아 관리한다. 
이 파일을 지우면 더 이상 깃으로 이 폴더의 변경사항을 추적할 수 없다.

## 스테이징

깃이 파일의 변경 내역을 저장하는데 바로 저장하는 것이 아니라 **"스테이징"**이라는 단계를 거친다. 
스테이징은 변경사항 중에서 저장하고 싶은 부분만 선택해 임시로 저장하는 개념이다. 
코드를 변경하고 깃 상태를 먼저 봐보자. 

```
git status
```

현재 변경사항이 어떤지 상태를 볼수 있는 명령어이다.

추적하고 싶은 파일을 스테이지에 넣기 위해서는 변경된 파일을 선택하거나,

```
git add file.ext
```

폴더의 전체 변경 사항을 지정한다.

```
git add .
```

스태이징에 들어간 파일은 이렇게 커밋 직전 상태로 변경된다.

```
git status

Changes to be committed:
  new file:   file.ext
```

## 커밋

깃은 변경 내용을 커밋 단위로 저장한다. 이처럼 먼저 스테이지 상태에 두어야만 비로소 커밋을 만들 수 있다. 
스테이지에 있는 내용으로 커밋을 만드려면 commit 명령어를 사용한다.

```
git commit 
```

기본 에디터가 열리고 변경 내용을 기록할 수 있는 입력 화면이 나온다. 
변경내용을 설명할 수 있는 텍스트를 입력하고 저장하면 커밋이 생성된다.

에디터를 열지않고 터미널에서 바로 메세지를 입력할 수 있는 `-m` 옵션도 자주 사용한다.

```
git commit -m "여기에 커밋메세지를 입력합니다."
```

매번 변경사항을 스테이징하고 커밋하는게 번거롭다면 `-a` 옵션을 사용하자. 
신규 파일을 제외하고 트래킹하는 모든 파일의  변경사항을 스테이징함과 동시에 커밋을 만들수 있는 옵션이다. 
`-m`과 함께 사용할 수 있다.

```
git commit -am "스태이징과 커밋을 한번에!"
```

커밋을 만들지 않고 이전 커밋에 변경사항을 추가하고 싶은 경우도 있다.
가끔 이전 커밋에 미쳐 포함하지 못한 코드가 있을 수 있다. 
이전 커밋에 현재 변경 내용을 추가할 때는 `--amend` 옵션을 사용한다.

```
git commit --amend
```

에디터가 뜨면서 마지막 커밋 메세지를 수정하는 화면이 나온다. 
저장하고 에디터를 닫으면 이전 커밋에 변경내용이 추가된다.

## 로그

스태이징을 거쳐 커밋한 것은 어떻게 볼수 있을까? 깃은 커밋 목록을 "로그(log)"라는 형식으로 볼 수 있다.

```
git log

commit 5ede63b20ee6237c345a7595d6f353c86eb3388b (HEAD -> master)
Author: Kim Jeonghwan <ej88ej@gmail.com>
Date:   Mon Feb 3 09:36:02 2020 +0900

    두번째 커밋입니다.

commit 289bd6a304b05cd11bafaf5416570b41ff96cf1c
Author: Kim Jeonghwan <ej88ej@gmail.com>
Date:   Mon Feb 3 09:26:06 2020 +0900

    첫번째 커밋입니다.
```

로그에는 두 개 커밋이 있는데 각 커밋을 식별할 수 있는 커밋 해쉬가 있다. 
뿐만 아니라 커밋 작성자와 작성일자, 그리고 커밋 메세지를 확인할 수 있다.

커밋에 변경내용이 반영되었는지 볼 수도 있다. 

```
git show 

 테스트 파일입니다.
-수정함
+지우고 수정함
```

삭제한 라인은 앞에 `-`를 추가한 라인은 `+`로 표시한다.

특정 커밋의 변경사항을 보고 싶다면 로그에 있는 커밋 해쉬로 볼 수 있다.

```
git show 289bd6a304b05cd11bafaf5416570b41ff96cf1c
```

## 브랜치

깃에서 중요한 또 하나의 개념은 "브랜치(branch)"다. 
로그에서 보는 것처럼 깃이 관리하는 변경이력은 마치 자라나는 나무같다.
그래서 깃 트리라고 하는지도 모르겠다. 
나무는 자라면서 또 다른 가지(branch)를 만드는데 깃도 이런 방식의 가지를 브랜치라고 한다.

브랜치를 만드는 이유는 뭘까? 지금하고 있는 작업과 성격이 다른 작업을 할때 브랜치를 만든다. 
가령 A 기능을 만들다가 B 기능을 만들어야 한다면 브랜치를 새로 만들어 B기능 개발을 하는 방식이다. 

깃은 기본적으로 master라는 이름의 브랜치를 하나 가지고 있다.

```
git branch

* master
```

지금 작업하고 있는 내용과 성격이 다른 작을 하기위해 feature라는 이름의 브랜치를 하나 만들어보자.

```
git branch feature master
git branch 

  feature
* master
```

그럼 feature 브랜치가 추가되서  총 두 개의 브랜치가 있다. 
여전히 현재 브랜치는 앞에 별표(*)가 있는 master 브랜치다.
새로 만든 브랜치로 이동하고 싶은데 깃에서 브랜치간의 선택은 "체크아웃한다(ckeckout)"라고 표현한다.

```
git checkout feature 
git branch 

* feature
  master
```

이 둘을 한번에 하려면, 즉 브랜치를 만들면서 선택하려면 기준 브랜치에서 -b 옵션을 주고 체크아웃 하는 방법이 있다. 
예를 들어 master 브랜치에서 feautre 브랜치를 만들고 체크아웃 하려면

```
git checkout -b feature
```

이렇게 하면된다.

feature 브랜치에서 개발하고 커밋을 계속 만든 뒤 그 다음 단계는 뭘가? 
브랜치에 만든 커밋들을 다시 원래 브랜치인 master애 반영해야 한다. 이것을 "병합(merge)"이라라고 부른다. 

```
git checkout master
git merge feature
```

기준이 되는 master 브랜치로 이동한 뒤 머지할 브랜치 feature를 머지한다.

## 헤드

브랜치간에 이동하다 보면 현제 내가 어느 브랜치에서 작업하는지 알아야 한다. 
branch 목록을 보면서 현재 브랜치를 알수 있다.

```
git branch
  
  feature
* master
```

앞에 별표된 것이 선택된 현재 브랜치다.

이것 뿐만 아니라 현재 위치를 좀 더 정확하게 보여주는 정보가 있는데 "머리(HEAD)"다. 
여러개 가지로 뻗어있는 나무에서 현재 위치를 나타내는 것이 헤드다.

```
git log 

commit 23427f8fb1baa80a5f0c9f974ba16dd0212edd69 (HEAD -> master)
commit d4b18ac8dc8f1e29a6082163b9329ffabd5bca96 (feature)
commit 18383c3d504208864ec73e7845d126a4824a43d6
```

master 브랜치 끝에 헤드가 표시되어 있다. 지금 작업하고 있는 위치다. 

헤드는 체크아웃 하면서 브랜치를 이동할 때 마다 변경한다. 
뿐만 아니라 체크아웃을 특정 커밋으로 이동할 수도 있다. 
이전 커밋을 체크아웃 할수도 있는데 헤더는 이동한 커밋으로 이동한다

```
git checkout 18383c3d504208864ec73e7845d126a4824a43d6
git log 

* 23427f8fb1baa80a5f0c9f974ba16dd0212edd69 (master)
* d4b18ac8dc8f1e29a6082163b9329ffabd5bca96 (feature)
* 18383c3d504208864ec73e7845d126a4824a43d6 (HEAD)
```


# 상황별 팁

## "원격 저장소와 연결하고 싶어요"

깃헙 같은 원격에 있는 저장소를 컴퓨터에 다룬로드하는 것을 "클론(clone)"이라고 한다. 
원격 저장소는 다운로드 하기위해 주소를 제공하는데 git으로 시작되는 주소나 https로 시작하는 주소를 제공한다. 
ssh방식이고 공개키가 서버에 등록되어 있다면 이 방식으로 다운로드할수 있다. 
후자는 아이디와 비빌번호를 사용해서 다운로드 할 수 있다. 
보통 깃헙을 원격저장소로 많이 사용하는데 공개키를 등록해서 ssh 방식으로 사용하는 편이다.

```
git clone {원격 저장소 주소}
```

다운로드한 원격 저장소는 저장소 이름으로 로컬에서 폴더로 생성된다. 
여기서 작업을하고 커밋을 만들고 한뒤 원격으로 내용을 업로드 하는 것을 “푸시”라고 한다. 

```
git push origin HEAD
```

협업하다보면 원격저장소를 클론한 다른 사용자가 코드를 먼저 푸시했을 수도 있다. 
이렇땐 저장소의 최신버전을 가져와야하는데 이것을 “패치”라고 한다.

```
git fetch
```

저장소의 최신 없데이트 내용을 가져올 수 있다.

```
git pull
```

원격 저장소의 변경 내용을 가져와 로컬 저장소에 반영한다. 패스트 포워드가 되면 반영하고 그렇지 않으면 머지한다. 

내가 작업한 내용을 깨끗히 유지하고 싶으면 머지 커밋을 만들지 않고 리베이스로 변경사항을 반영할수 있다. 

```
git pull --rebase
```

이렇게 하면 원격저장소에 있는 변경사항을 먼저 쌓고 그 위에 내가 작업한 변경사항을 쌓는 방식이다. 
나는 머지보다는 리베이스를 선호하는 편이다. 커밋 그래프를 좀더 단순하게 유지하고 싶어서 그렇게 한다. 

## "원격 저장소를 여러개 관리하고 싶어요"

클론하면 기본적으 원격저장소는 하나다. 자명하다. 이때 저장소의 이름은 “origin” 이다.

```
git remote -v
```

원격 저장소는 여러개 붙일수 있다. 원격 저장소가 여러개 있어야할 이유는 뭘까? 
깃헙 포크를 이용하면 이게 무척 유용하다. 
포크하면 남의 계정의 저장소를 내 계정의 저장소로 하나 가져오는 기능이다. 
내 계정으로 포크한 저장소를 클론하면 기본 이름인 origin으로 가져오게된다. 
만약 원본 계정 저장소의 변경사항이 있는데 이걸 가져오고 싶으면 어떻게할까? 
이때 원격 저장소 하나를 더 추가할 수 있다. 보통은 upstream이란 이름으로 원격저장소 하나를 더 추가한다.

```
git remote add upstream {원격저장소주소}
```

이렇게 하면 하나의 저장소에 두 개의 원격지와 연결할수 있다. 
내 원격저장소에 코드 변경사항을 origin으로 푸시하다가 원본 저장소의 변경사항을 받을때는 upstream으로 접근할 수 있다.

원격 저장소의 주소를 변경하고 싶은때는 set-url로 변경할 수있다.

```
git remote set-url {변경된 원격저장소주소}
```

물론 원격 저장소의 이름을 변경할 수도 있다.

```
git remote -m {저장소이름} {저장소이름 신규}
```

## "필요한 라인만 커밋하고 싶어요"

보통 변경된 파일을 스태이지에 넣고 이것을 커밋하기 때문에 파일단위로 묶어서 커밋하게 된다. 
의미있는 커밋 메세지를 유지하려다 보면 라인 단위로 커밋 변경사항을 묶고 싶을 경우가 있다. 
커밋을 위해 변경사하을 복사 붙여넣기 했다면 이런 방식도 사용해 보길 바란다.

```
git add -p
```

스태이징할때 변경한 라인만 추가할수 있는 것이 -p 옵션이다. 
이렇게 하면 변경된 파일을 하나씩 열어 스태이지에 넣을지 말지 결정하면 된다.

![gif]

split를 입력하면 변경 단위를 더 세밀하게 쪼겐다. 

![gif]

이것도 만족스럽지 않다면 편집 모드로 들어가 라인 단위로 선택할 수 있다

![gif]

이렇게 선택적으로 스태이징한 뒤 커밋하면 훨씬 의미있는 커밋을 만들 수 있다. 
커밋할때 -v 옵션을 주면 스태이징 된 라인을 볼수 있어서 한번더 체크할 수 있다.

```
git commit -v
```

## "히스토리를 예쁘게 보고 싶어요"

로그 트리때문에 터미널에서 깃을 사용하는걸 부담스럽게 여긴다면 잠깐만 여길 봐 보시라. 
깃 로그 명령어는 꽤 많은 옵션을 가지고 있다. 먼저 graph 옵션으로 로그를 봐 보자

```
git log --graph
```

터미널에서도 그래프를 볼수 있다는 점에 놀라웠는가? 이제 여기에다가 조금씩 그래프를 예쁘게 만들어 볼수 있다. 

보통 커밋해쉬를 다 보진 않는다. 해쉬값 전체를 사용하는 경우도 없었고 말이다. (내경험은 그랬다) 
커밋 해쉬값을 앞에 7자만 간단히 보여주는 것이 좋겠다. abbrev-commit 옵션을 추가해 보자

```
git log --graph --abbrev-commit
```

커밋해쉬값이 짧아져서 좀 덜 부담스럽다. 

하나의 로그가 좀 길다. 중요한 메세지만 남기고 로그 그래프를 더 보고 싶다면 pretty 옵션을 추가 해보자.

```
git log --graph  --abbrev-commit --decorate  --pretty=oneline
```

커밋 해시와 메세지만 한 줄로 나오고 더 많은 커밋 그래프를 볼수 있다. 

트리에는 대신에 브랜치와 태그 정보도 없어져 버렸는데 decorate 옵션을 추가해보자.

```
git log --graph  --abbrev-commit --pretty=oneline --decorate   
```

색상에 민감한 편인가 그럼 format 옵션으로 한땀한땀 취향에 맞는 색상을 골라보자.

```
git log --graph  --abbrev-commit --pretty=oneline --decorate  --format
```

밋밋했던 커밋 로그가 그래픽 도구 못지 않게 훌륭해졌다. 
문제는 이러한 긴명령어를 매번 입력해야 하냐는 것이다. 급한분은 아래 “별칭” 부분으로 넘어가 읽어보길 바란다.

## "히스토리를 변경하고 싶어요"

A작업을 마치고 커밋, B작업을 마치고 커미, A’ 작업을 마치고 커밋을 만들었다. 
이왕이면 관련된 커밋을 한곳으로 모으고 싶다. 
지라따위의 애자일 도구를 사용한다면 지라 번호로 커밋 메세지를 만들텐데 프피릭스에 지라 번호를 붙여서 메세지를 작성할 것이다.

```
TASK-A 작업함
TASK-B 작업함
TASK-A 추가 작업함
```

마지막 두개 커밋을 순서를 바꾸면 작업을 이해하는데 더 좋을 것 같다. 
코드의 가독성 뿐만 아니라 커밋의 가독성도 그것 만큼 중요하니깐 말이다.

리베이스로 커밋 순서를 변경할 수있다.

```
git rebase -i HEAD~3
```

에디터가 열려 커밋 목록이 나오고 여기서 순서를 변경할 수 있다.

만약 두개 커밋을 하나로 합치고 싶다면 f를 사용하면된다.

커밋 메세지를 수정하고 싶다면 r을 사용한다. 

## "브랜치간의 변경사항을 보고 싶어요"

mater브랜치를 운영서버에 배포하고 develop 브랜치를 개발서버에 배포하는 구조라고 하자. 
오늘이 배포하는 날이다. 어떤 사항을 배포하는 확인하고 싶을 경우가 있다. 커밋 단위로 말이다. 
즉 지금 운영중인 master 브랜치에 비해 오늘까지 개발한 develop 브랜치의 변경사항을 커밋별로 보고 싶을 때는 아래 명령어를 사용하자.

```
git log mater..develop
```

매번 순서가 헷갈리는데 나만의 노하우는…(// todo)

## "커밋의 변경내용을 자세히 보고 싶어요"

```
git show 
git show --state
```

## "빈 브랜치를 만들고 싶어요"

--orphan

## 없어진 커밋을 되살리고 싶어요"

git reflog

## "히스토리에서 파일을 제거하고 싶어요"

## "머지하다가 충돌은 어떻게 해결하나요"

충돌 상황 설명
충돌 주석의 역할
충돌 처리 
이건 리베이스에도 발생할 수 있다.

## "머지할때 커밋을 꼭 만들고 싶어요"

Fast Forward에 대한 설명 

```
git merge --no-ff
```

## "커밋하기는 그렇고… 임시로 변경사항을 저장할수 있나요?"
```
git stash
```

# 기타

## 깃 단축키

.gitconfig > alias

## 깃 명령어 단축키 
g (zsh 기본 별칭인가?)
별칭을 추가하는 방법은? alias?

## vim 사용이 어렵다면?

vscode

# 정리

코드뿐만아니라 글도 깃을 활용하면 좋다. 
워드파일처럼 어플리케이션만의 인코딩 처리 후 저장 방식은 변경사항까지 추적하는건 어렵다. 
마크다운을 사용한다면 좋다. 김정환 블로그가 그렇다.
