---
title: 깃(Git) 개념과 상활별 팁
layout: post
category: dev
tags: git
---

[git-usage](https://github.com/jeonghwan-kim/git-usage) 저장소가 어느새 스타 100을 넘었다. 
에버노트에 정리한 것을 깃헙에 공유한 것인데 필요한 분들이 그만큼 많았나 보다. 
다시 쭉 읽어보니 기억하려고 메모 형식으로 명령어만 나열해 놓은 거라서 이해하기 어려운 부분도 종종 눈에 띈다.
여기에 살을 덧붙여 **"깃 노하우"** 혹은 **"팁"**을 정리해 보면 좋겠다. 

# 기본 개념과 명령어

## 깃 초기화

깃을 올바로 사용하려면 깃이 파일의 변경 내용을 추적하는 방식을 이해하는 것이 무척 중요하다.
그렇지 않고 백업 용도로만 깃을 사용하면 장님이 코끼리 만지는 것처럼 딱 그만큼만 알게 되기 때문이다.

깃은 어떤 파일이 있는 폴더라도 모든 파일을 트래킹 할 수 있다. 
원하는 폴더로 이동해 깃 명령어로 초기화하는 작업을 선행한다.

```
git init
```

.git 라는 이름의 숨김 폴더가 하나 생긴다. 
이것을 저장소라고 하는데 깃은 이 폴더에 파일의 변경 내용을 추적하는 정보를 담아서 관리한다. 
이 파일을 지우면 더 이상 깃으로 이 폴더의 변경사항을 추적할 수 없다.

## 스테이징

깃이 파일의 변경 내역을 저장하는데 곧바로 저장하는 것이 아니라 **"스테이징"**이라는 단계를 거친다. 
스테이징은 변경사항 중에서 "저장하고 싶은 부분만 선택해 임시로 저장"하는 개념이다. 
코드를 변경하고 깃 상태를 먼저 봐보자. 

```
git status

Untracked files:
  (use "git add <file>..." to include in what will be committed)

  file.txt
```

폴더의 현재 변경 상태를 볼수 있는 명령어이다.
폴더에는 file.txt 파일이 있는데 아직 깃이 이 파일을 트래킹하지 않아서 "Untracked files" 목록에 있다.

추적하고 싶은 파일을 스테이지에 넣기 위해서는 변경된 파일을 선택하거나,

```
git add file.ext
```

폴더의 전체 변경 사항을 지정한다.

```
git add .
```

스태이징에 들어간 파일은 이렇게 커밋 직전 상태로 변경된다.

```
git status

Changes to be committed:
  new file:   file.ext
```

## 커밋

깃은 변경 내용을 커밋 단위로 저장한다. 이처럼 먼저 스테이지 상태에 두어야만 비로소 커밋을 만들 수 있다. 
스테이지에 있는 내용으로 커밋을 만드려면 commit 명령어를 사용한다.

```
git commit 
```

기본 에디터가 열리고 변경 내용을 기록할 수 있는 입력 화면이 나온다. 
변경 내용을 설명할 수 있는 텍스트를 입력하고 저장하면 커밋이 생성된다.

에디터를 열지않고 터미널에서 바로 메세지를 입력할 수 있는 `-m` 옵션도 자주 사용한다.

```
git commit -m "여기에 커밋메세지를 입력합니다."
```

매번 변경사항을 스테이징하고 커밋하는게 번거롭다면 `-a` 옵션을 사용하자. 
신규 파일을 제외하고 트래킹하는 모든 파일의 변경사항을 스테이징함과 동시에 커밋을 만들 수 있는 옵션이다. 
`-m`과 함께 사용할 수 있다.

```
git commit -am "스태이징과 커밋을 한번에!"
```

커밋을 만들지 않고 이전 커밋에 변경사항을 추가하고 싶은 경우도 있다.
가끔 이전 커밋에 미쳐 포함하지 못한 코드가 있을 수 있는데,
이전 커밋에 현재 변경 내용을 추가할 때는 `--amend` 옵션을 사용한다.

```
git commit --amend
```

에디터가 뜨면서 마지막 커밋 메세지를 수정하는 화면이 나온다. 
저장하고 에디터를 닫으면 이전 커밋에 변경내용이 추가된다.

## 로그

스태이징을 거쳐 커밋한 결과를 어떻게 볼 수 있을까? 
깃은 커밋 목록을 "로그(log)"라는 형식으로 볼 수 있다.

```
git log

commit 5ede63b20ee6237c345a7595d6f353c86eb3388b (HEAD -> master)
Author: Kim Jeonghwan <ej88ej@gmail.com>
Date:   Mon Feb 3 09:36:02 2020 +0900

  두번째 커밋입니다.

commit 289bd6a304b05cd11bafaf5416570b41ff96cf1c
Author: Kim Jeonghwan <ej88ej@gmail.com>
Date:   Mon Feb 3 09:26:06 2020 +0900

  첫번째 커밋입니다.
```

로그에는 두 개 커밋이 있는데 각 커밋을 식별할 수 있는 커밋 해쉬가 있다. 
뿐만 아니라 커밋 작성자와 작성일자, 그리고 커밋 메세지를 확인할 수 있다.

커밋에 변경 내용이 반영되었는지 볼 수도 있다. 

```
git show 

 테스트 파일입니다.
-수정함
+지우고 수정함
```

삭제한 라인은 앞에 `-`를 추가한 라인은 `+`로 표시한다.

특정 커밋의 변경사항을 보고 싶다면 로그에 있는 커밋 해쉬로 볼 수 있다.

```
git show 289bd6a304b05cd11bafaf5416570b41ff96cf1c
```

## 브랜치

깃에서 중요한 또 하나의 개념은 "브랜치(branch)"다. 
로그에서 보는 것처럼 깃이 관리하는 변경 이력은 마치 자라나는 나무같다.
그래서 깃 트리라고 하는지도 모르겠다. 
나무는 자라면서 또 다른 가지를 만드는데 깃도 이런 방식의 가지를 브랜치라고 한다.

브랜치를 만드는 이유는 뭘까? 지금하고 있는 작업과 성격이 다른 작업을 할 때 브랜치를 만든다. 
가령 A 기능을 만들다가 B 기능을 만들어야 한다면 브랜치를 새로 만들어 B를 개발하는 방식이다. 

깃은 기본적으로 master라는 이름의 브랜치를 하나 가지고 있다.

```
git branch

* master
```

지금 작업하고 있는 내용과 성격이 다른 작업을 하기 위해 feature라는 이름의 브랜치를 하나 만들어보자.

```
git branch feature master
git branch 

  feature
* master
```

그럼 feature 브랜치가 추가되어 총 두 개의 브랜치가 있다. 
여전히 현재 브랜치는 앞에 별표(*)가 있는 master 브랜치다.
새로 만든 브랜치로 이동하고 싶은데 깃에서 브랜치간의 선택은 "체크아웃한다(ckeckout)"라고 표현한다.

```
git checkout feature 
git branch 

* feature
  master
```

이 둘을 한번에 하려면, 즉 브랜치를 만들면서 선택하려면 기준 브랜치에서 -b 옵션을 주고 체크아웃 하는 방법이 있다. 
예를 들어 master 브랜치에서 feautre 브랜치를 만들고 체크아웃 하려면 이렇게 하면된다.

```
git checkout -b feature
```

feature 브랜치에서 개발하고 커밋을 계속 만든 뒤 그 다음 단계는 뭘까? 
브랜치에 만든 커밋들을 다시 원래 브랜치인 master에 반영해야 한다. 이것을 "병합(merge)"이라라고 부른다. 

```
git checkout master
git merge feature
```

기준이 되는 master 브랜치로 이동한 뒤 머지할 브랜치 feature를 머지한다.

## 헤드

브랜치간에 이동하다 보면 현재 내가 어느 브랜치에서 작업하는지 알아야 한다. 
branch 목록을 보면서 현재 브랜치를 알수 있다.

```
git branch
  
  feature
* master
```

앞에 별표된 것이 선택된 현재 브랜치다.

이것 뿐만 아니라 위치를 좀 더 정확하게 보여주는 정보가 있는데 "머리(HEAD)"다. 
여러개 가지로 뻗어있는 나무에서 현재 위치를 나타내는 것이 헤드다.

```
git log 

commit 23427f8fb1baa80a5f0c9f974ba16dd0212edd69 (HEAD -> master)
commit d4b18ac8dc8f1e29a6082163b9329ffabd5bca96 (feature)
commit 18383c3d504208864ec73e7845d126a4824a43d6
```

master 브랜치 끝에 헤드가 표시되어 있다. 지금 작업하고 있는 위치다. 

헤드는 체크아웃 하면서 브랜치를 이동할 때 마다 수시로 변경된다.
뿐만 아니라 특정 커밋으로 체크아웃 할 수 있는데 이 때도 헤드는 그 커밋으로 옮겨진다.

```
git checkout 18383c3d504208864ec73e7845d126a4824a43d6
git log 

* 23427f8fb1baa80a5f0c9f974ba16dd0212edd69 (master)
* d4b18ac8dc8f1e29a6082163b9329ffabd5bca96 (feature)
* 18383c3d504208864ec73e7845d126a4824a43d6 (HEAD)
```

# 상황별 팁

이 정도로 깃에 대해 개념을 잡고 아래 상황별로 깃 명령어를 어떻게 사용할 수 있는지 알아보자.
순서대로 읽지 않아도 된다. 필요한 부분으로가서 어떤 방식으로 문제를 해결하는지 바로 확인해 보자.

## "필요한 라인만 커밋하고 싶어요"

보통 변경된 파일을 스태이지에 넣고 이것을 커밋하기 때문에 커밋은 파일단위로 묶이게 된다.
의미있는 커밋 메세지를 유지하려다보면, 파일의 각 라인 단위로 변경사항을 묶고 싶을 경우가 있다.
지금까지 이런식의 커밋을 위해 변경된 내용을 복사 붙여넣기 했다면 아래 방식도 사용해 보길 바란다.

```
git add -p
```

변경한 라인만 스태이지에 넣는 것이 바로 `-p` 옵션이다. 
이렇게 하면 변경된 파일을 하나씩 열어 스태이지에 넣을지말지 결정하면 된다.

```
 기존 코드입니다.

+여기는 나중에 커밋하고요

 기존 코드입니다.

-
+이 부분을 커밋하고 싶어요.
+이곳도 나중에 커밋합니다.
Stage this hunk [y,n,q,a,d,s,e,?]? s
```

split를 입력하면 변경 단위를 더 세밀하게 쪼겐다. 

```
기존 코드입니다.

+여기는 나중에 커밋하고요

 기존 코드입니다.

 Stage this hunk [y,n,q,a,d,j,J,g,/,e,?]? n
```

기존 코드 기준으로 변경사항을 분할해서 보여준다. 
이 부분을 스태이징에서 제외하려면 n을 입력하고 다음 분할 부분으로 넘어간다.

```
 기존 코드입니다.

+이 부분을 커밋하고 싶어요.
+이곳도 나중에 커밋합니다.
Stage this hunk [y,n,q,a,d,K,g,/,e,?]? e
```

추가된 코드가 연속으로 있을경우 s 명령어로 분할 할수 없다. 
깃은 기존의 코드를 기준으로 분할하는 것 같기 때문이다. 
이러한 경우에는 e를 입력하고 편집 모드로 들어가 직접 스테이징에 포함할 라인을 선별할 수 있다.

```
# Manual hunk edit mode -- see bottom for a quick guide.
4  기존 코드입니다.
5
7 +이 부분을 커밋하고 싶어요.
8 +이곳도 나중에 커밋합니다. --> 스테이징에서 제외하려면 이 라인을 삭제한다
```

추가된 코드 중 7번 라인만 스테이징에 넣을 것이니깐 아래 8번 라인은 제거하면 된다.
모두 선택하면 스태이징 작업이 끝난다. 
이렇게 선택적으로 스태이징한 뒤 커밋하면 훨씬 의미있는 커밋을 만들 수 있다. 

이제 이걸 커밋으로 생성해야하는데 커밋에 `-v` 옵션을 주면 스태이징된 부분을 자세히 볼 수 있다.

```
git commit -v
```

## "커밋의 변경내용을 자세히 보고 싶어요"

깃은 파일의 변경 내용과 이를 요약 메세지, 작성자, 작성일 등의 메타 정보를 모두 합쳐서 하나의 커밋을 만들어 낸다.
log 명령어로 간단한 커밋 정보를 볼 수 있었다면 show 명령어로 더 자세한 내용도 조회할 수 있다.

```
git show 

 기존 코드입니다.

-여기는 삭제될 부분이에요.

+여기를 마지막에 추가했어요
```

기존 내용에서 삭제/추가한 부분으로 나누어 표시한다.
삭제한 줄은 `-`로 추가한 줄은 `+`로 확인할 수 있다.

그런데 깃 트리에 있는 많은 커밋중에 어떤 커밋의 내용을 보여주는 걸까?
show는 기본적으로 HEAD가 가리키고 있는 커밋의 정보를 조회한다. 
특정 커밋의 내용을 보려면 커밋 식별자인 커밋 해쉬를 이용해서 볼 수 있다.

```
git show 7ad18c6b000554ed69dbabe7344b67d8beda6915
# 혹은
git show 7ad18c6
```

해쉬값을 사용하거나 이 값이 너무 기니깐 앞의 7자리만 사용해서 해쉬값에 해당하는 커밋의 변경사항을 볼 수 있다.

커밋에서 변경사항이 많을 경우, 많은 파일을 변경했을 때는 파일별로 변경내용을 요약해서 볼 수도 있다.

```
git show --stat

 두개 파일을 수정합니다

 file.txt  | 5 +++--
 file2.txt | 1 +
 2 files changed, 4 insertions(+), 2 deletions(-)
```

file.txt는 5개 라인을 변경했는데 3줄을 추가하고 2줄 삭제했다.
file2.txt는 1줄을 추가했다.
총 2개 파일을 변경했고 4줄 추가하고 2줄 삭제한 커밋이다.

주로 과거에 작업했던 내용을 찾아볼 때 이 명령어를 자주 사용한다.
어떤 내용을 변경했는지 라인별로 확인하고 한 커밋에 변경한 파일이 많으면 `--stat` 옵션으로 파일 목록을 확인한다.

그리고나서 커밋의 파일 목록중에 특정 파일의 변경사항은 파일명을 지정해서 확인하는 편이다.

```
git show 7ad18c6 file.txt
```

이렇게 커밋 내용을 확인할 수 있기때문에 웬만하면 주석는 그냥 지우는 편이다.
삭제했다는 내용의 커밋을 저장하고 나중에 주석 대신에 삭제한 커밋을 들여다 보는것이 더 단순하게 느껴지기 때문이다.


## "커밋하기는 그렇고… 임시로 변경사항을 저장할수 있나요?"

작업을 하다가 임시 저장해야하는 상황이 있다. 커밋 메세지도 떠오르지 않고 그냥 잠깐 저장하고 다른 작업을 하고 싶을때 그렇다.
처음에는 "WIP"(Work In Progress) 라는 작업중 메세지로 커밋을 만들곤 했었다. 

하지만 몇 년전부턴 다른 분이 stash 명령어를 사용하는 걸 보곤 나도 무척 잘 활용하고 있다. 
'숨겨두다'라는 의미의 이 명령어는 커밋하기는 그렇고 저장은 해야하는 이런 상황을 위한 것이다. 

```
git stash
```

이 명령어를 실행하고 나면 현제 폴더의 변경내용이 다른 어딘가로 저장되고 변경된 내용이 파일에서 사라진다.

스태쉬도 커밋처럼 하나의 단위로 저장되는 스태시 목록을 확인할 수 있다.

```
git stash list

stash@{0}: WIP on master: 7ad18c6 두개 파일을 수정합니다
```

여기서 한번더 내용을 수정하고 스태시하고 목록을 보면 추가된 스태시가 기존 스태시 위에 쌓인다.
스택처럼 말이다.

```
git stash list

stash@{0}: WIP on master: 7ad18c6 두개 파일을 수정합니다
stash@{1}: WIP on master: 7ad18c6 두개 파일을 수정합니다
```

임시 저장한 변경 내용을 되돌리려면 스택처럼 팝으로 꺼낼수 있다.

```
git stash pop
```

그럼 임시 저장했던 변경 내용들이 파일에 다시 복구된 것을 확인할 수 있다.

지라 같은 업무 관리 툴로 일을 하다보면 업무 간에 스위칭이 잦은 경우가 있다. 
이때 잠시 스태쉬로 지금 작업 내용을 저장하고 다른 업무을 보면 좀더 코드 관리하기가 편리했던 것 같다.


## "히스토리를 예쁘게 보고 싶어요"

로그 트리 때문에 터미널에서 깃을 사용하는걸 부담스럽게 여긴다면 잠깐만 여길 봐 보시라. 
깃 로그 명령어는 꽤 많은 옵션을 가지고 있다. 먼저 --graph 옵션으로 로그를 봐 보자

```
git log --graph
```

![log-1](/assets/imgs/2020/02/03/log-1.jpg)

터미널에서도 그래프를 볼수 있다는 점에 놀라웠는가? 이제 여기에다가 조금씩 그래프를 예쁘게 만들어 볼수 있다. 

보통 커밋해쉬를 다 보진 않는다. 해쉬값 전체를 사용하는 경우도 없었고 말이다. (내경험은 그랬다) 
커밋 해쉬값을 앞에 7자만 간단히 보여주는 것이 좋겠다. abbrev-commit 옵션을 추가해 보자

```
git log --graph --abbrev-commit
```

![log-2](/assets/imgs/2020/02/03/log-2.jpg)

커밋해쉬값이 짧아져서 좀 덜 부담스럽다. 

하나의 로그가 좀 길다. 중요한 메세지만 남기고 로그 그래프를 더 보고 싶다면 pretty 옵션을 추가 해보자.

```
git log --graph  --abbrev-commit --pretty=oneline
```

![log-3](/assets/imgs/2020/02/03/log-3.jpg)

커밋 해시와 메세지만 한 줄로 나오고 더 많은 커밋 그래프를 볼수 있다. 

모든 브래치와 태그를 함께 보고 싶은가? 

```
git log --graph  --abbrev-commit --pretty=oneline --all
```

![log-4](/assets/imgs/2020/02/03/log-4.jpg)

밋밋했던 커밋 로그가 그래픽 도구 못지 않게 훌륭해졌다. 
문제는 이러한 긴 명령어를 매번 입력해야 하냐는 것이다. 
급한분은 아래 "별칭" 부분으로 넘어가 읽어보길 바란다.

## "히스토리를 변경하고 싶어요"

A작업을 마치고 커밋, B작업을 마치고 커미, A’ 작업을 마치고 커밋을 만들었다. 
이왕이면 관련된 커밋을 한곳으로 모으고 싶다. 
지라따위의 애자일 도구를 사용한다면 지라 번호로 커밋 메세지를 만들텐데 프피릭스에 지라 번호를 붙여서 메세지를 작성할 것이다.

```
TASK-A 작업함
TASK-B 작업함
TASK-A 추가 작업함
```

마지막 두개 커밋을 순서를 바꾸면 작업을 이해하는데 더 좋을 것 같다. 
코드의 가독성 뿐만 아니라 커밋의 가독성도 그것 만큼 중요하니깐 말이다.

리베이스로 커밋 순서를 변경할 수있다.

```
git rebase -i HEAD~3
```

에디터가 열려 커밋 목록이 나오고 여기서 순서를 변경할 수 있다.

만약 두개 커밋을 하나로 합치고 싶다면 f를 사용하면된다.

커밋 메세지를 수정하고 싶다면 r을 사용한다. 

## "머지하다가 충돌은 어떻게 해결하나요"

충돌 상황 설명
충돌 주석의 역할
충돌 처리 
이건 리베이스에도 발생할 수 있다.

## "머지할때 커밋을 꼭 만들고 싶어요"

Fast Forward에 대한 설명 

```
git merge --no-ff
```


## "브랜치간의 변경사항을 보고 싶어요"

mater브랜치를 운영서버에 배포하고 develop 브랜치를 개발서버에 배포하는 구조라고 하자. 
오늘이 배포하는 날이다. 어떤 사항을 배포하는 확인하고 싶을 경우가 있다. 커밋 단위로 말이다. 
즉 지금 운영중인 master 브랜치에 비해 오늘까지 개발한 develop 브랜치의 변경사항을 커밋별로 보고 싶을 때는 아래 명령어를 사용하자.

```
git log mater..develop
```

매번 순서가 헷갈리는데 나만의 노하우는…(// todo)


## "빈 브랜치를 만들고 싶어요"

--orphan

## 없어진 커밋을 되살리고 싶어요"

git reflog

## "히스토리에서 파일을 제거하고 싶어요"


## "원격 저장소와 연결하고 싶어요"

깃헙 같은 원격에 있는 저장소를 컴퓨터에 다룬로드하는 것을 "클론(clone)"이라고 한다. 
원격 저장소는 다운로드 하기위해 주소를 제공하는데 git으로 시작되는 주소나 https로 시작하는 주소를 제공한다. 
ssh방식이고 공개키가 서버에 등록되어 있다면 이 방식으로 다운로드할수 있다. 
후자는 아이디와 비빌번호를 사용해서 다운로드 할 수 있다. 
보통 깃헙을 원격저장소로 많이 사용하는데 공개키를 등록해서 ssh 방식으로 사용하는 편이다.

```
git clone {원격 저장소 주소}
```

다운로드한 원격 저장소는 저장소 이름으로 로컬에서 폴더로 생성된다. 
여기서 작업을하고 커밋을 만들고 한뒤 원격으로 내용을 업로드 하는 것을 “푸시”라고 한다. 

```
git push origin HEAD
```

협업하다보면 원격저장소를 클론한 다른 사용자가 코드를 먼저 푸시했을 수도 있다. 
이렇땐 저장소의 최신버전을 가져와야하는데 이것을 “패치”라고 한다.

```
git fetch
```

저장소의 최신 없데이트 내용을 가져올 수 있다.

```
git pull
```

원격 저장소의 변경 내용을 가져와 로컬 저장소에 반영한다. 패스트 포워드가 되면 반영하고 그렇지 않으면 머지한다. 

내가 작업한 내용을 깨끗히 유지하고 싶으면 머지 커밋을 만들지 않고 리베이스로 변경사항을 반영할수 있다. 

```
git pull --rebase
```

이렇게 하면 원격저장소에 있는 변경사항을 먼저 쌓고 그 위에 내가 작업한 변경사항을 쌓는 방식이다. 
나는 머지보다는 리베이스를 선호하는 편이다. 커밋 그래프를 좀더 단순하게 유지하고 싶어서 그렇게 한다. 

## "원격 저장소를 여러개 관리하고 싶어요"

클론하면 기본적으 원격저장소는 하나다. 자명하다. 이때 저장소의 이름은 “origin” 이다.

```
git remote -v
```

원격 저장소는 여러개 붙일수 있다. 원격 저장소가 여러개 있어야할 이유는 뭘까? 
깃헙 포크를 이용하면 이게 무척 유용하다. 
포크하면 남의 계정의 저장소를 내 계정의 저장소로 하나 가져오는 기능이다. 
내 계정으로 포크한 저장소를 클론하면 기본 이름인 origin으로 가져오게된다. 
만약 원본 계정 저장소의 변경사항이 있는데 이걸 가져오고 싶으면 어떻게할까? 
이때 원격 저장소 하나를 더 추가할 수 있다. 보통은 upstream이란 이름으로 원격저장소 하나를 더 추가한다.

```
git remote add upstream {원격저장소주소}
```

이렇게 하면 하나의 저장소에 두 개의 원격지와 연결할수 있다. 
내 원격저장소에 코드 변경사항을 origin으로 푸시하다가 원본 저장소의 변경사항을 받을때는 upstream으로 접근할 수 있다.

원격 저장소의 주소를 변경하고 싶은때는 set-url로 변경할 수있다.

```
git remote set-url {변경된 원격저장소주소}
```

물론 원격 저장소의 이름을 변경할 수도 있다.

```
git remote -m {저장소이름} {저장소이름 신규}
```

# 기타

## 깃 단축키

.gitconfig > alias

## 깃 명령어 단축키 
g (zsh 기본 별칭인가?)
별칭을 추가하는 방법은? alias?

## vim 사용이 어렵다면?

vscode

# 정리

코드뿐만아니라 글도 깃을 활용하면 좋다. 
워드파일처럼 어플리케이션만의 인코딩 처리 후 저장 방식은 변경사항까지 추적하는건 어렵다. 
마크다운을 사용한다면 좋다. 김정환 블로그가 그렇다.
