---
title: '앵귤러 개발자가 놓치기 쉬운 10가지 사실들'
layout: post
tags:
  angularjs
summary:
---

앵귤러를 처음 접한건 전문 개발자로서의 커리어를 시작한 순간부터였다. 웹 개발은 학교에서 APM 기반의 지식이 전부였고 간단한 텀프로젝트를 만들었던 수준이라서 '나는 웹 개발자 입니다' 라고 말하기 민망할 정도였다. 제이쿼리를 사용하긴 하지만 간단한 돔 조작을 하는 정도 수준이지 복잡한 이벤트를 다룬다거나 하는 그런 어려운 것은 대부분 인터넷에서 구하기 쉬운 라이브러리를 사용했다.

위플래닛에 입사하고 웹개발을 시작하기에 앞서 어떤 프레임웍을 선택하느냐가 네게 주어진 질문이었다. 그 당시 까지만 해도 제이쿼리가 모든 프론트엔드 개발자들의 주된 도구였고 BackboneJS 같은 MVC 패턴을 구현할 수 있는 프레임웍도 시중에 나와 있었다. 그러나 백본을 배워보고 싶은 이유는 없었는데 이유는 잘 모르겠다. 오히려 구글에서 이제 막 오픈한 앵귤러 프레임웍이 멋져보였고 이것으로 웹개발 시작을 끊었다.

서점에 나온 앵귤러 입문서를 읽거나 관련된 블로그 포스팅을 보면서 앵귤러를 학습했다. 그러나 앵귤러 공식 사이트에 있는 개발자 가이드라인을 일독한 것은 이번이 처음이었다. 사실 하나의 프레임웍을 공부하려면 해당 사이트에서 제공하는 문서를 보는 것이 가장 정확한 방법인데 그렇게 하지 못했다. 글을 읽으면서 그동안 간과했던 부분들을 발견했고 이번 글에서 그것들에 대해 간단히 정리해 보고자 한다.


## 인터폴레이션({{ }})보다는 ng-bind를 사용하자

가끔 누군가에게 앵귤러로 헬로 월드를 가르치다 보면 인터폴레이션 ({{ }}) 문자열이 순간적으로 나오는데 왜그러냐고 질문 받는다. 그리고 대안이 없는지 궁금해 한다. 인터폴레이션 문법을 사용한것은 단지 금방 코딩해서 보여줄수 있기 때문이다. 사실은 인터폴레이션을 사용한 곳의 코드를 모두 ng-bind 디렉티브로 변경해서 사용한다. 그러면 스콥 변수에 데이터가 할당될 때까지는 빈 문자열이 출력 된다.

```
(코드 샘플. Plunker)
```

## One time binding (::)을 사용하자

그럼에도 불구하고 인터폴레이션을 사용해야 할때는 원 타임 바인딩(One time binding)을 사용하는 것을 고려해 볼 수 있다. 그냥 바인딩 하게되면 스콥 변수가 변화하는 것에 따라서 뷰에 출력되는 값이 달라진다. 이것은 스콥에서 그 바인딩된 변수를 감시(watch)하고 있기 때문이다. 바인딩된 변수가 많을 수록 감시해야 할 것은 많아지고 브라우져는 메모리를 잡아 먹게된다.

한번 원타임 바인딩을 사용하게되면 스콥변수에 할당된 초기값이 뷰에 출력된다. 이후 그 변수값이 변경되더라도 뷰는 업데이트되지 않는다. 이것은 스콥 변수가 그 바인딩된 변수를 감시하지 않기 때문이며 그만큼 메모리를 절약할 수 있다.

```
(코드 샘플. Plunker)
```


## window.location 보다는 $location 서비스를 사용하자

* 라이프 싸이클이 있다.
* 이건 코드를 먼저 작성하고 진행하자


## 폼을 사용할 때는 ng-form을 사용하자

앵귤러 폼을 사용하게 되면 좋은 점이 한 두가지가 아니다. 폼은 사용자 입력을 받는 것이 첫번째 목적이다. 사용자는 폼에 입력해야할 값을 잘 모른다. 무슨말이냐 하면 전화번호 입력란에 숫자만 입력하는 것인지 하이프(-)도 넣어도 되는지 혹은 국가번호도 넣어야하는지 잘 모른다는 말이다. 따라서 사용자 입력에 대해 입력값 검증을 수행해야 하는데 제이쿼리로 이것을 일일이 검증하는 것은 상당히 수고로운 작업이다. 나도 초기에는 앵귤러 폼을 사용하지 않고 컨트롤러 함수에서 폼 입력값에대한 검증 코드를 일일이 작성했었다. 하지만 앵귤러 폼을 사용하면 선언적인 방법으로 폼을 검증 로직을 추가할 수 있다.

```html
<form name=“myFrom” ng-submit=“submit()”>
     <input type=“text” name="username" ng-model="username" ng-minlength=“2” ng-maxlength=“20” ng-trim=“true” required/>
     <input type=“password” name="password" ng-model="password" minlength=“6” required />
     <button type=“submit”></button>
</form>
```

이렇게 사용하면 선언하면 사용자 이름(username)은 길이 2에서 20 사이의 문자열을 입력하고 빈칸을 제거하는 제한을 설정할 수 있다. 그리고 비밀번호(password)는 6자리 이상으로 입력하도록 한다. 그리고 두 필드는 반드시 입력한 뒤 제출(submit)하도록 설정한 것이다.

만약 이러한 검증을 만족하지 못하게되면 앵귤러 폼 로직에 따라 $scope.myForm.$invalid 플래그가 활성화 되어 폼 입력값이 잘못되었다는 것을 인지할 수 있다. 그리고 $scope.myForm.$errors 배열에 검증을 통과하지 못한 에러 정보가 담긴다. 각 입력 필드에는 ng-invalid 라는 CSS 클래스가 추가되는데 이 클래스를 재정의 함으로써 잘못 입력한 필드를 UI적으로 강조할 수 있다.

좀더 자세한 내용을 아래 링크를 확인해 보길 바란다.

* [Angular Form](/angular-form)
* [ngForm 클래스명 활용하기](/ngform-클래스명-활용하기)
* [ngForm-밸리데이터-활용](/ngform-밸리데이터-활용)
* [ngForm-사용자-정의-밸리데이터-만들기](ngform-사용자-정의-밸리데이터-만들기)


## 디렉티브를 만들때는 독립 스코프를 만들자

리엑트의 컴포넌트와 비교할수 있는 것이 앵귤러의 디렉티브가 아닐까 생각한다. 하나의 독립된 HTML 컴포넌트로 만들수 있고 여러 곳에서 재사용해서 사용할수 있는 점 때문에 그렇다. 하지만 디렉티브를 만들때 부모 스콥을 사용한다면, 그러니깐 예를 들어 컨트롤러의 스코프 영향을 받는 다면 온전히 독립된 디렉티브라 할수 없다. 특정환경에서만 동작하는 디렉티브가 되어 버린다. 따라서 앵귤러 문서에서는 이렇게 사용하라고 권고 한다.

> Use the scope option to create isolate scopes when making components that you want to reuse throughout your app.
재사용하기 위한 컴포넌트를 만들때는 독립된 스코프를 만들기위해 스코프 옵션을 사용하세요.

디렉티브 사용법은 아래 링크를 더 읽어보기 바란다.

* [앵귤러로 Todo앱 만들기 8 - Directive](/lectures/todomvc-angular/8/)


## ng-show와 ng-if의 차이점


## Dependency Injection할 때 주의할 사항

앵귤러에서 강조하는 것중 하나가 의존성 주입, Dependency Indection이다. 말도 너무 어렵고 여전히 이게 어떻게 구동하는지 명확히 파악하지는 못하지만 이 개념때문에 앵귤러에서 각 컴포넌트들을 독립적으로 모듈화할 수 있고 테스트하기도 쉽다는 것을 실감한다. 앵귤러에서 인젝션 할수 있는 것은 서비스다. 어떤 서비스인지 그 구현은 모르더라도 아래처럼 서비스를 주입할 수 있다.

```javascript
angular.module('myapp')
    .controller('MyCtrl', function ($scope, myService) {
      // myService를 사용할 수 있다.
    });
```

myService를 myapp 모듈 범위내 어디선가 정의해 놓고 MyCtrl 이란 컨트롤러에서 이 서비스를 사용할 수 있는데 컨트롤러 정의할때 controller() 함수 두번째 파라매터의 함수의 파라매터로 넣는 방식이다. 이렇게 의존성 주입을 설정할 수 있지만 문제는 다음과 같은 상황에서 발생한다.

프론트엔드에서 사용하는 자바스크립트 코드는 서버에서 브라우져로 다운로드 되어 실행되는 방식이다. 따라서 다운로드할 자비스크립트 코드의 용량이 적을수록 웹페이지를 접하는 사용자에게는 빠른 웹사이트가 된다. 따라서 현대의 자바스크립트는 코드를 용량을 줄이기 위해 변수명을 짦게 바꾸는 등 용량을 최소하려고 노력한다. 또한 상용화된 서비스의 코드가 다른 개발자에 의해 쉽게 읽혀지지 않도록 하기위해 난독화 작업을 수행한다. 위 코드를 압축하고 난독화 하면 아마 이런 코드로 변경될 것이다.

```javascript
angular.module('myapp')
    .controller('MyCtrl', function (a, b) {
    });
```

반드시 그런것은 아니지만 변수만큼은 a, b처럼 짧게 변경된다. 왜냐하면 변수명은 개발자가 식별할수 있어야 하기 때문에 $scope, myService 이지만 브라우져가 볼때는 a, b로 해도 상관없기 때문이다. 그러나 여기서 문제가 발생한다. 브라우져는 a가 $scope이고 b가 mySerivce라는 것을 알지못한다. 따라서 그러한 단서를 제공해야 하는데 [Inline Array Annotaion](https://docs.angularjs.org/guide/di#inline-array-annotation)으로 코드를 작성하면 된다.

```javascript
angular.module('myapp')
    .controller('MyCtrl', ['$scope', 'myService', function ($scope, myService) {
    }]);
```

이것을 압축하면 아래와 같이 변경될 것이다.

```javascript
angular.module('myapp')
    .controller('MyCtrl', ['$scope', 'myService', function (a, b) {
    }]);
```

문자열은 압축 대상이 아니기 때문에 배열에 넣은 '$scope', 'myService'는 그대로 남아있고 배열의 세 번째로 넣은 함수의 파라매터 변수만 a, b로 변경되었다. 앵귤러는 이 단서를 가지고 a 는 $scope 이고 b는 myService라는 서비스라고 판단할 수 있는 것이다.

처음엔 코드를 압축하고 나서 실행하면 가끔 브라우져 콘솔에 에러가 발생하는데 이것이 원인이었던 경우가 많았었다. 뭐가 없다라고 하는데 잘 못찼겠고 그 땐 앵귤러가 너무 멀게만 느겨졌었다. 이런 앵귤러만의 특성을 파악하고 나면 좀더 가까워지지 않을까 생각한다.


## compile과 link의 차이점


## 뷰에 독립적인 비즈니스로직은 서비스로 만들것


## 컨트롤러에서 돔을 조작하지 말것

directive로 만들어라.
돔만 조작하려면 차라리 jQuery를 사용
